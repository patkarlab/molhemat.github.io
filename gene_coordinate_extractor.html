<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Gene Coordinate Extractor tool from the Molecular Hematology Research Group at ACTREC, Tata Memorial Centre." />
<title>Gene Coordinate Extractor â€“ Molecular Hematology Research Group</title>
<style>
  :root {
    --ink: #0a1e78;
    --mut: #D80000;
    --panel-bg: rgba(255,255,255,0.92);
    --border: #d4d0c8;
    --border-strong: #b8b4aa;
    --muted: #6b6b6b;
    --code-bg: #eae8e3;
    --table-stripe: #f2f0ec;
    --accent-green: #2d6a4f;
    --accent-light: #d8f3dc;
    --shadow: 0 2px 12px rgba(10,30,120,0.08);
    --radius: 6px;
  }

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  html { font-size: 16px; -webkit-font-smoothing: antialiased; }

  body {
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    background: #ffffff;
    color: var(--ink);
    line-height: 1.6;
    min-height: 100vh;
    position: relative;
    overflow-x: hidden;
  }

  /* Navigation bar */
  .nav {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
    display: flex;
    gap: 8px;
    background: rgba(255,255,255,0.85);
    padding: 8px;
    border-radius: 999px;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    box-shadow: 0 2px 12px rgba(10,30,120,0.08);
  }
  .nav a {
    text-decoration: none;
    color: var(--ink);
    font-weight: 500;
    padding: 10px 20px;
    border-radius: 999px;
    transition: all 0.2s ease;
    font-size: 14px;
    white-space: nowrap;
  }
  .nav a:hover { background: rgba(10,30,120,0.08); }
  .nav a.active { background: var(--ink); color: white; }

  /* Canvas positioning */
  #nucleotideCanvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    pointer-events: none;
    opacity: 0.35;
  }

  /* Main content container */
  .container {
    position: relative;
    z-index: 10;
    min-height: 100vh;
    padding: 100px 20px 80px;
    max-width: 1000px;
    margin: 0 auto;
  }

  /* Panel styling */
  .panel {
    background: var(--panel-bg);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    border-radius: 20px;
    padding: clamp(20px, 4vw, 40px);
    box-shadow: 0 8px 30px rgba(10,30,120,0.07);
    margin-bottom: 24px;
  }

  /* Header */
  .tool-header h1 {
    font-size: clamp(24px, 4vw, 36px);
    font-weight: 700;
    color: var(--ink);
    margin-bottom: 8px;
    letter-spacing: -0.02em;
  }
  .tool-header h1 .mut { color: var(--mut); }
  .tool-header .subtitle {
    color: var(--muted);
    font-size: clamp(14px, 2vw, 16px);
    max-width: 640px;
    margin-bottom: 4px;
    line-height: 1.5;
  }
  .genome-badge {
    display: inline-block;
    font-family: monospace;
    font-size: 12px;
    padding: 3px 10px;
    background: var(--ink);
    color: white;
    border-radius: 999px;
    margin-top: 8px;
    letter-spacing: 0.04em;
  }

  /* Mode tabs */
  .mode-tabs {
    display: flex;
    gap: 0;
    margin-bottom: 24px;
    border-bottom: 2px solid rgba(10,30,120,0.15);
  }
  .mode-tab {
    padding: 10px 20px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    border: none;
    background: none;
    color: var(--muted);
    position: relative;
    transition: color 0.15s;
  }
  .mode-tab:hover { color: var(--ink); }
  .mode-tab.active { color: var(--mut); }
  .mode-tab.active::after {
    content: '';
    position: absolute;
    bottom: -2px;
    left: 0;
    right: 0;
    height: 2px;
    background: var(--mut);
  }

  /* Form sections */
  .form-section { margin-bottom: 20px; }
  label {
    display: block;
    font-size: 13px;
    font-weight: 600;
    letter-spacing: 0.03em;
    text-transform: uppercase;
    color: var(--muted);
    margin-bottom: 6px;
  }
  label .hint {
    text-transform: none;
    font-weight: 400;
    letter-spacing: 0;
    display: block;
    margin-top: 2px;
    font-size: 12px;
    color: #999;
  }

  textarea {
    width: 100%;
    min-height: 140px;
    padding: 12px 14px;
    font-family: monospace;
    font-size: 14px;
    line-height: 1.65;
    border: 1px solid rgba(10,30,120,0.2);
    border-radius: var(--radius);
    background: #fff;
    color: var(--ink);
    resize: vertical;
    transition: border-color 0.15s;
  }
  textarea:focus {
    outline: none;
    border-color: var(--ink);
    box-shadow: 0 0 0 3px rgba(10,30,120,0.08);
  }
  textarea::placeholder { color: #bbb; }

  .options-row {
    display: flex;
    gap: 24px;
    align-items: flex-end;
    flex-wrap: wrap;
  }
  .option-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .option-group input[type="number"],
  .option-group select {
    padding: 8px 12px;
    font-family: monospace;
    font-size: 14px;
    border: 1px solid rgba(10,30,120,0.2);
    border-radius: var(--radius);
    background: #fff;
    color: var(--ink);
  }
  .option-group input[type="number"]:focus,
  .option-group select:focus {
    outline: none;
    border-color: var(--ink);
    box-shadow: 0 0 0 3px rgba(10,30,120,0.08);
  }
  .option-group input[type="number"] { width: 80px; }
  .option-group select { min-width: 140px; cursor: pointer; }

  /* Buttons */
  .btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 10px 22px;
    font-size: 14px;
    font-weight: 600;
    border-radius: 999px;
    border: none;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  .btn-primary {
    background: var(--ink);
    color: #fff;
  }
  .btn-primary:hover { background: #0d2690; box-shadow: 0 4px 12px rgba(10,30,120,0.2); }
  .btn-primary:disabled {
    background: var(--border);
    color: var(--muted);
    cursor: not-allowed;
    box-shadow: none;
  }
  .btn-secondary {
    background: #fff;
    color: var(--ink);
    border: 1px solid rgba(10,30,120,0.2);
  }
  .btn-secondary:hover { border-color: var(--ink); background: rgba(10,30,120,0.04); }
  .btn-secondary:disabled {
    color: var(--border);
    cursor: not-allowed;
  }

  .actions-row {
    display: flex;
    gap: 12px;
    align-items: center;
    flex-wrap: wrap;
    margin-top: 20px;
  }

  /* Status / log */
  #status-area { margin-top: 24px; display: none; }
  #status-area.visible { display: block; }

  .log-box {
    background: var(--ink);
    color: #c8c8c8;
    font-family: monospace;
    font-size: 13px;
    line-height: 1.7;
    padding: 16px 18px;
    border-radius: var(--radius);
    max-height: 200px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-break: break-all;
  }
  .log-box .log-ok { color: #95d5b2; }
  .log-box .log-warn { color: #f4a261; }
  .log-box .log-err { color: #e76f51; }
  .log-box .log-info { color: #89b4fa; }

  /* Progress */
  .progress-bar {
    height: 3px;
    background: rgba(10,30,120,0.15);
    border-radius: 2px;
    margin-bottom: 12px;
    overflow: hidden;
  }
  .progress-bar-fill {
    height: 100%;
    background: var(--mut);
    width: 0%;
    transition: width 0.3s ease;
  }

  /* Results */
  #results-area { margin-top: 32px; display: none; }
  #results-area.visible { display: block; }

  .results-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    flex-wrap: wrap;
    gap: 12px;
  }
  .results-header h2 {
    font-size: 20px;
    font-weight: 700;
    color: var(--ink);
  }
  .results-header .count {
    font-family: monospace;
    font-size: 13px;
    color: var(--muted);
  }

  .results-table-wrapper {
    overflow-x: auto;
    border: 1px solid rgba(10,30,120,0.15);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    background: #fff;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 14px;
  }
  thead th {
    font-family: monospace;
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: var(--muted);
    text-align: left;
    padding: 10px 14px;
    border-bottom: 2px solid rgba(10,30,120,0.15);
    background: var(--table-stripe);
    position: sticky;
    top: 0;
    white-space: nowrap;
  }
  tbody td {
    padding: 7px 14px;
    font-family: monospace;
    font-size: 13px;
    border-bottom: 1px solid #eee;
    white-space: nowrap;
  }
  tbody tr:nth-child(even) { background: var(--table-stripe); }
  tbody tr:hover { background: rgba(10,30,120,0.04); }

  td.region-int { color: var(--accent-green); }
  td.region-exon { color: #6c3483; font-weight: 500; }

  .result-section { margin-bottom: 32px; }
  .result-section:last-child { margin-bottom: 0; }

  .section-label {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
  }
  .section-label h3 {
    font-size: 16px;
    font-weight: 700;
    color: var(--ink);
  }
  .section-label .section-tag {
    font-family: monospace;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    padding: 2px 8px;
    border-radius: 3px;
  }
  .section-tag-exon { background: #f0e6f6; color: #6c3483; }
  .section-tag-intron { background: var(--accent-light); color: var(--accent-green); }
  .section-label .section-count {
    font-family: monospace;
    font-size: 12px;
    color: var(--muted);
    margin-left: auto;
  }
  .transcript-badge {
    display: inline-block;
    font-family: monospace;
    font-size: 12px;
    padding: 2px 7px;
    background: var(--code-bg);
    border-radius: 3px;
    color: var(--ink);
  }

  /* Footer */
  .tool-footer {
    font-size: 12px;
    color: var(--muted);
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 16px;
    padding-top: 16px;
    border-top: 1px solid rgba(10,30,120,0.1);
  }

  .footer {
    position: fixed;
    left: 0; right: 0; bottom: 12px;
    text-align: center;
    font-size: 11px;
    opacity: .6;
    z-index: 10;
    padding: 0 20px;
    pointer-events: none;
  }

  /* Spinner */
  .spinner {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid rgba(255,255,255,0.3);
    border-top-color: #fff;
    border-radius: 50%;
    animation: spin 0.6s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  .hidden { display: none !important; }

  /* Responsive */
  @media (max-width: 768px) {
    .nav { top: 12px; padding: 6px; gap: 4px; }
    .nav a { padding: 8px 14px; font-size: 13px; }
    .container { padding: 88px 14px 60px; }
    .panel { padding: clamp(16px, 5vw, 32px); border-radius: 16px; }
    .options-row { flex-direction: column; gap: 16px; }
    .actions-row { flex-direction: column; }
    .btn { width: 100%; justify-content: center; }
    .results-header { flex-direction: column; align-items: flex-start; }
    #nucleotideCanvas { opacity: 0.45; }
  }

  @media (max-width: 380px) {
    .nav { gap: 2px; padding: 4px; }
    .nav a { padding: 6px 10px; font-size: 12px; }
  }

  @media (min-width: 1200px) {
    .nav a { font-size: 16px; padding: 12px 24px; }
  }

  @media (prefers-reduced-motion: reduce) {
    #nucleotideCanvas { display: none; }
  }

  @media (max-width: 768px) and (pointer: coarse) {
    #nucleotideCanvas { opacity: 0.45; }
  }
</style>
</head>
<body>

<!-- Navigation -->
<nav class="nav">
  <a href="index.html">Home</a>
  <a href="team.html">Team</a>
  <a href="research.html">Research</a>
  <a href="publications.html">Publications</a>
  <a href="tools.html">Tools</a>
  <a href="social.html">Social</a>
</nav>

<!-- Animated nucleotide rain canvas (background) -->
<canvas id="nucleotideCanvas" aria-hidden="true"></canvas>

<!-- Main content -->
<main class="container" role="main">
  <div class="panel">
    <div class="tool-header">
      <h1><span class="mut">Gene Coordinate</span> Extractor</h1>
      <p class="subtitle">
        Retrieve exonic and intronic coordinates for human genes using the MANE Select
        transcript. All queries run client-side against the UCSC REST API.
      </p>
      <span class="genome-badge" id="topbar-genome">GRCh38 / hg38</span>
    </div>
  </div>

  <div class="panel">
    <!-- Mode tabs -->
    <div class="mode-tabs">
      <button class="mode-tab active" data-mode="regions" onclick="switchMode('regions')">
        Specific Regions
      </button>
      <button class="mode-tab" data-mode="genes" onclick="switchMode('genes')">
        Whole Gene
      </button>
    </div>

    <!-- Mode 1: Specific regions -->
    <div id="panel-regions" class="form-section">
      <label for="input-regions">
        Regions
        <span class="hint">One per line: GENE_int_N or GENE_exon_N (e.g. ALK_int_19, BRAF_exon_15)</span>
      </label>
      <textarea id="input-regions" spellcheck="false" placeholder="ALK_int_15
ALK_int_16
ALK_int_17
ALK_int_18
ALK_int_19
ALK_int_20
ALK_int_21
ALK_exon_20
BRAF_exon_15"></textarea>
    </div>

    <!-- Mode 2: Whole gene -->
    <div id="panel-genes" class="form-section hidden">
      <label for="input-genes">
        Gene Symbols
        <span class="hint">One per line (e.g. ALK, BRAF, ROS1). All exons and introns will be extracted.</span>
      </label>
      <textarea id="input-genes" spellcheck="false" placeholder="ALK
BRAF
ROS1"></textarea>
    </div>

    <!-- Options -->
    <div class="options-row">
      <div class="option-group">
        <label for="genome-select">
          Reference Genome
          <span class="hint">Genome assembly for coordinate queries</span>
        </label>
        <select id="genome-select" onchange="switchGenome(this.value)">
          <option value="hg38" selected>hg38 (GRCh38)</option>
          <option value="hg19">hg19 (GRCh37)</option>
        </select>
      </div>
      <div class="option-group">
        <label for="flank-input">
          Exon flank (bp)
          <span class="hint">Extend exonic regions into flanking introns (e.g. 10 for splice sites)</span>
        </label>
        <input type="number" id="flank-input" value="0" min="0" max="1000" step="1">
      </div>
    </div>

    <!-- Actions -->
    <div class="actions-row">
      <button class="btn btn-primary" id="btn-run" onclick="run()">
        Extract Coordinates
      </button>
      <button class="btn btn-secondary" id="btn-download" onclick="downloadBED()" disabled>
        Download BED
      </button>
      <button class="btn btn-secondary" id="btn-clear" onclick="clearResults()">
        Clear
      </button>
    </div>

    <!-- Status -->
    <div id="status-area">
      <div class="progress-bar"><div class="progress-bar-fill" id="progress-fill"></div></div>
      <div class="log-box" id="log-box"></div>
    </div>

    <!-- Results -->
    <div id="results-area">
      <div class="results-header">
        <h2>Results</h2>
        <span class="count" id="results-count"></span>
      </div>
      <div id="results-container"></div>
    </div>

    <div class="tool-footer">
      <span id="footer-info">Coordinates: 0-based, half-open (BED convention). Transcript: MANE Select via ncbiRefSeqSelect.</span>
      <span>No data leaves your browser.</span>
    </div>
  </div>
</main>

<footer class="footer">&copy; <span id="year"></span> Molecular Hematology Research Group &middot; ACTREC &middot; TMC</footer>

<script>
document.getElementById('year').textContent = new Date().getFullYear();

// ===========================================================================
// Nucleotide rain background (matching other pages)
// ===========================================================================
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

const canvas = document.getElementById("nucleotideCanvas");
const bgCtx = canvas.getContext("2d");

const BG_SPEED_FACTOR = isMobile ? 0.25 : 0.45;
const BG_LIFETIME_MS  = isMobile ? 2200 : 2800;
const BG_MUT_RATE     = 0.03;
const BG_COL_WIDTH    = isMobile ? 44 : 32;
const BG_ROW_SCALE_MIN = 1.3;
const BG_ROW_SCALE_MAX = 1.7;

function resizeCanvas() {
  const dpr = isMobile ? Math.min(window.devicePixelRatio || 1, 2) : (window.devicePixelRatio || 1);
  canvas.style.position = "fixed";
  canvas.style.top = 0;
  canvas.style.left = 0;
  canvas.style.width = window.innerWidth + "px";
  canvas.style.height = window.innerHeight + "px";
  canvas.width = Math.floor(window.innerWidth * dpr);
  canvas.height = Math.floor(window.innerHeight * dpr);
  bgCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
resizeCanvas();

const bgBases = ["A","T","G","C"];
let bgColumns = [];
let animationId = null;

function bgRand(a,b){ return a + Math.random()*(b-a); }

function newBgColumn(i) {
  const fontSize = isMobile ? (14 + Math.random() * 20) : (18 + Math.random() * 28);
  const rowScale = bgRand(BG_ROW_SCALE_MIN, BG_ROW_SCALE_MAX);
  return {
    x: i * BG_COL_WIDTH + Math.floor(BG_COL_WIDTH * 0.5),
    y: Math.random() * window.innerHeight,
    speed: (0.8 + Math.random() * 1.2) * BG_SPEED_FACTOR,
    fontSize,
    rowStep: fontSize * rowScale,
    depth: 0.6 + Math.random() * 0.8,
    lastEmitY: 0,
    trail: []
  };
}

function rebuildBgColumns() {
  const count = Math.max(1, Math.floor(window.innerWidth / BG_COL_WIDTH));
  const maxCols = isMobile ? 12 : 36;
  const finalCount = Math.min(count, maxCols);
  bgColumns = new Array(finalCount).fill(0).map((_, i) => {
    const c = newBgColumn(i);
    c.lastEmitY = c.y;
    return c;
  });
}
rebuildBgColumns();

const bgEaseOutQuad = t => 1 - (1 - t) * (1 - t);

let lastBgFrame = 0;
const bgTargetFPS = isMobile ? 30 : 60;
const bgFrameDelay = 1000 / bgTargetFPS;

function drawBg(now) {
  if (isMobile && (now - lastBgFrame) < bgFrameDelay) {
    animationId = requestAnimationFrame(drawBg);
    return;
  }
  lastBgFrame = now;

  bgCtx.globalAlpha = 1;
  bgCtx.fillStyle = "#ffffff";
  bgCtx.fillRect(0, 0, window.innerWidth, window.innerHeight);

  bgColumns.forEach((col, idx) => {
    col.y += col.speed * col.depth;

    while (col.y - col.lastEmitY >= col.rowStep) {
      col.lastEmitY += col.rowStep;
      const char = bgBases[(Math.random() * bgBases.length) | 0];
      const isMut = Math.random() < BG_MUT_RATE;
      col.trail.push({
        x: col.x, y: col.lastEmitY, char,
        color: isMut ? "#D80000" : "rgb(10,30,120)",
        size: col.fontSize, born: now
      });
    }

    if (col.y > window.innerHeight + col.rowStep) {
      const next = newBgColumn(idx);
      next.y = 0;
      next.lastEmitY = -next.rowStep;
      bgColumns[idx] = next;
    }

    const alive = [];
    const maxTrailLength = isMobile ? 8 : 14;
    for (let i = 0; i < Math.min(col.trail.length, maxTrailLength); i++) {
      const g = col.trail[i];
      const age = now - g.born;
      if (age <= BG_LIFETIME_MS) {
        const t = age / BG_LIFETIME_MS;
        const alpha = (1 - bgEaseOutQuad(t)) * 0.8;
        bgCtx.globalAlpha = alpha;
        if (!isMobile) {
          bgCtx.shadowColor = g.color;
          bgCtx.shadowBlur = Math.max(0, (g.size - 18) * 0.15);
        }
        bgCtx.font = `${g.size}px monospace`;
        bgCtx.fillStyle = g.color;
        bgCtx.fillText(g.char, g.x, g.y);
        alive.push(g);
      }
    }
    col.trail = alive;
  });

  bgCtx.globalAlpha = 1;
  bgCtx.shadowBlur = 0;
  animationId = requestAnimationFrame(drawBg);
}

animationId = requestAnimationFrame(drawBg);

let resizeTimeout;
window.addEventListener("resize", () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => { resizeCanvas(); rebuildBgColumns(); }, 250);
});

document.addEventListener("visibilitychange", () => {
  if (document.hidden && animationId) { cancelAnimationFrame(animationId); animationId = null; }
  else if (!document.hidden && !animationId) { animationId = requestAnimationFrame(drawBg); }
});

const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
function handleMotionPreference() {
  if (mediaQuery.matches) {
    if (animationId) { cancelAnimationFrame(animationId); animationId = null; }
    bgCtx.clearRect(0, 0, canvas.width, canvas.height);
  } else if (!animationId) { animationId = requestAnimationFrame(drawBg); }
}
mediaQuery.addEventListener?.('change', handleMotionPreference);
handleMotionPreference();

// ===========================================================================
// Tool State
// ===========================================================================
let currentMode = 'regions';
let resultRows = [];

const GENOME_CONFIG = {
  hg38: { ucsc: 'hg38', label: 'hg38', fullLabel: 'GRCh38 / hg38' },
  hg19: { ucsc: 'hg19', label: 'hg19', fullLabel: 'GRCh37 / hg19' },
};
let currentGenome = 'hg38';

function getGenome() {
  return GENOME_CONFIG[currentGenome];
}

// ===========================================================================
// UI helpers
// ===========================================================================
function switchGenome(genome) {
  currentGenome = genome;
  const cfg = getGenome();
  document.getElementById('topbar-genome').textContent = cfg.fullLabel;
  document.title = 'Gene Coordinate Extractor | ' + cfg.label;
}

function switchMode(mode) {
  currentMode = mode;
  document.querySelectorAll('.mode-tab').forEach(t => {
    t.classList.toggle('active', t.dataset.mode === mode);
  });
  document.getElementById('panel-regions').classList.toggle('hidden', mode !== 'regions');
  document.getElementById('panel-genes').classList.toggle('hidden', mode !== 'genes');
}

function setRunning(running) {
  const btn = document.getElementById('btn-run');
  if (running) {
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner"></span> Running...';
  } else {
    btn.disabled = false;
    btn.textContent = 'Extract Coordinates';
  }
}

function showStatus() {
  document.getElementById('status-area').classList.add('visible');
}

function setProgress(pct) {
  document.getElementById('progress-fill').style.width = pct + '%';
}

const logEl = document.getElementById('log-box');
function log(msg, cls) {
  const span = document.createElement('span');
  if (cls) span.className = cls;
  span.textContent = msg + '\n';
  logEl.appendChild(span);
  logEl.scrollTop = logEl.scrollHeight;
}

function clearLog() {
  logEl.innerHTML = '';
  setProgress(0);
}

function clearResults() {
  resultRows = [];
  document.getElementById('results-area').classList.remove('visible');
  document.getElementById('status-area').classList.remove('visible');
  document.getElementById('results-container').innerHTML = '';
  document.getElementById('btn-download').disabled = true;
  clearLog();
}

function buildTable(rows) {
  const wrapper = document.createElement('div');
  wrapper.className = 'results-table-wrapper';
  const table = document.createElement('table');
  table.innerHTML = `
    <thead>
      <tr>
        <th>Chrom</th>
        <th>Start</th>
        <th>End</th>
        <th>Name</th>
        <th>RefSeq ID</th>
        <th>Strand</th>
      </tr>
    </thead>
  `;
  const tbody = document.createElement('tbody');
  rows.forEach(r => {
    const tr = document.createElement('tr');
    const isExon = r.name.includes('_exon_');
    const cls = isExon ? 'region-exon' : 'region-int';
    tr.innerHTML = `
      <td>${r.chrom}</td>
      <td>${r.start.toLocaleString()}</td>
      <td>${r.end.toLocaleString()}</td>
      <td class="${cls}">${r.name}</td>
      <td><span class="transcript-badge">${r.refseq}</span></td>
      <td>${r.strand}</td>
    `;
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
  wrapper.appendChild(table);
  return wrapper;
}

function renderResults() {
  const container = document.getElementById('results-container');
  container.innerHTML = '';

  const geneOrder = [];
  const geneMap = {};
  resultRows.forEach(r => {
    const gene = r.name.replace(/_(exon|int)_.*$/, '');
    if (!geneMap[gene]) {
      geneMap[gene] = { exons: [], introns: [], refseq: r.refseq, strand: r.strand };
      geneOrder.push(gene);
    }
    if (r.name.includes('_exon_')) {
      geneMap[gene].exons.push(r);
    } else {
      geneMap[gene].introns.push(r);
    }
  });

  for (const gene of geneOrder) {
    const g = geneMap[gene];

    if (g.exons.length > 0) {
      const section = document.createElement('div');
      section.className = 'result-section';
      section.innerHTML = `
        <div class="section-label">
          <h3>${gene}</h3>
          <span class="section-tag section-tag-exon">Exons</span>
          <span class="transcript-badge">${g.refseq}</span>
          <span class="section-count">${g.exons.length} region${g.exons.length !== 1 ? 's' : ''}</span>
        </div>
      `;
      section.appendChild(buildTable(g.exons));
      container.appendChild(section);
    }

    if (g.introns.length > 0) {
      const section = document.createElement('div');
      section.className = 'result-section';
      section.innerHTML = `
        <div class="section-label">
          <h3>${gene}</h3>
          <span class="section-tag section-tag-intron">Introns</span>
          <span class="transcript-badge">${g.refseq}</span>
          <span class="section-count">${g.introns.length} region${g.introns.length !== 1 ? 's' : ''}</span>
        </div>
      `;
      section.appendChild(buildTable(g.introns));
      container.appendChild(section);
    }
  }

  const totalExons = Object.values(geneMap).reduce((s, g) => s + g.exons.length, 0);
  const totalIntrons = Object.values(geneMap).reduce((s, g) => s + g.introns.length, 0);
  document.getElementById('results-count').textContent =
    `${totalExons} exon${totalExons !== 1 ? 's' : ''}, ${totalIntrons} intron${totalIntrons !== 1 ? 's' : ''} across ${geneOrder.length} gene${geneOrder.length !== 1 ? 's' : ''}`;
  document.getElementById('results-area').classList.add('visible');
  document.getElementById('btn-download').disabled = resultRows.length === 0;
}

// ===========================================================================
// UCSC API
// ===========================================================================
const UCSC = 'https://api.genome.ucsc.edu';

async function ucscSearch(gene) {
  const genome = getGenome().ucsc;
  const url = `${UCSC}/search?genome=${genome}&search=${encodeURIComponent(gene)}`;
  const r = await fetch(url);
  if (!r.ok) throw new Error(`UCSC search failed for ${gene}: ${r.status}`);
  return r.json();
}

async function ucscTrack(track, chrom, start, end) {
  const genome = getGenome().ucsc;
  const url = `${UCSC}/getData/track?genome=${genome}&track=${track}&chrom=${chrom}&start=${start}&end=${end}`;
  const r = await fetch(url);
  if (!r.ok) throw new Error(`UCSC track fetch failed: ${r.status}`);
  return r.json();
}

// ===========================================================================
// Gene location resolution
// ===========================================================================
function parsePosition(pos) {
  const m = pos.match(/^(chr[\dXYMT]+):(\d+)-(\d+)$/);
  if (!m) return null;
  return { chrom: m[1], start: parseInt(m[2]), end: parseInt(m[3]) };
}

function findGeneLocation(searchData, gene) {
  const matches = searchData.positionMatches || [];
  const geneUp = gene.toUpperCase();

  for (const group of matches) {
    const desc = group.description || '';
    if (desc.includes('MANE') || desc.includes('HUGO')) {
      for (const m of (group.matches || [])) {
        if ((m.posName || '').toUpperCase() === geneUp) {
          return parsePosition(m.position || '');
        }
      }
    }
  }
  for (const group of matches) {
    for (const m of (group.matches || [])) {
      if ((m.posName || '').toUpperCase() === geneUp) {
        return parsePosition(m.position || '');
      }
    }
  }
  return null;
}

// ===========================================================================
// Transcript resolution
// ===========================================================================
async function getMANESelect(gene, chrom, start, end) {
  const data = await ucscTrack('ncbiRefSeqSelect', chrom, start, end);
  const items = data.ncbiRefSeqSelect || [];
  const geneUp = gene.toUpperCase();
  return items.find(t =>
    (t.name2 || '').toUpperCase() === geneUp && (t.name || '').startsWith('NM_')
  ) || null;
}

async function getAllRefSeq(gene, chrom, start, end) {
  const data = await ucscTrack('ncbiRefSeq', chrom, start, end);
  const items = data.ncbiRefSeq || [];
  const geneUp = gene.toUpperCase();
  const seen = new Set();
  return items.filter(t => {
    if ((t.name2 || '').toUpperCase() !== geneUp) return false;
    if (!(t.name || '').startsWith('NM_')) return false;
    if (seen.has(t.name)) return false;
    seen.add(t.name);
    return true;
  });
}

async function resolveTranscript(gene, chrom, start, end) {
  const mane = await getMANESelect(gene, chrom, start, end);
  if (mane) {
    log(`  MANE Select: ${mane.name}`, 'log-ok');
    return mane;
  }

  const allTx = await getAllRefSeq(gene, chrom, start, end);
  if (allTx.length === 0) {
    log(`  ERROR: No NM_ transcripts found for ${gene}.`, 'log-err');
    return null;
  }
  if (allTx.length === 1) {
    log(`  Single NM_ transcript: ${allTx[0].name}`, 'log-info');
    return allTx[0];
  }

  log(`  No MANE Select for ${gene}. Available:`, 'log-warn');
  const options = allTx.map((t, i) => {
    const len = t.txEnd - t.txStart;
    return `[${i + 1}] ${t.name} (${t.exonCount} exons, ${len.toLocaleString()} bp)`;
  });
  options.forEach(o => log('    ' + o, 'log-warn'));

  const choice = prompt(
    `No MANE Select transcript found for ${gene}.\n\n` +
    `Choose a transcript:\n` +
    options.join('\n') +
    `\n\nEnter number (1-${allTx.length}):`
  );

  const idx = parseInt(choice) - 1;
  if (isNaN(idx) || idx < 0 || idx >= allTx.length) {
    log(`  Invalid selection. Skipping ${gene}.`, 'log-err');
    return null;
  }
  log(`  Selected: ${allTx[idx].name}`, 'log-ok');
  return allTx[idx];
}

// ===========================================================================
// Exon / intron computation
// ===========================================================================
function parseTranscript(tx) {
  const chrom = tx.chrom;
  const strand = tx.strand;

  const exonStarts = tx.exonStarts.replace(/,$/,'').split(',').map(Number);
  const exonEnds = tx.exonEnds.replace(/,$/,'').split(',').map(Number);

  let exonRegions = exonStarts.map((s, i) => ({ chrom, start: s, end: exonEnds[i] }));

  let intronRegions = [];
  for (let i = 0; i < exonRegions.length - 1; i++) {
    intronRegions.push({
      chrom,
      start: exonRegions[i].end,
      end: exonRegions[i + 1].start,
    });
  }

  if (strand === '-') {
    exonRegions = exonRegions.reverse();
    intronRegions = intronRegions.reverse();
  }

  exonRegions.forEach((r, i) => r.number = i + 1);
  intronRegions.forEach((r, i) => r.number = i + 1);

  return { exons: exonRegions, introns: intronRegions };
}

// ===========================================================================
// Input parsing
// ===========================================================================
function parseRegionsInput(text) {
  const pattern = /^([A-Za-z0-9_.\-]+)_(int|intron|exon)_(\d+)$/i;
  const geneRegions = {};

  text.split('\n').forEach((raw, idx) => {
    const line = raw.trim();
    if (!line || line.startsWith('#')) return;
    const m = line.match(pattern);
    if (!m) {
      log(`  WARNING: skipping line ${idx + 1}: '${line}'`, 'log-warn');
      return;
    }
    const gene = m[1].toUpperCase();
    let type = m[2].toLowerCase();
    if (type === 'intron') type = 'int';
    const num = parseInt(m[3]);
    if (!geneRegions[gene]) geneRegions[gene] = [];
    geneRegions[gene].push({ type, number: num });
  });

  return geneRegions;
}

function parseGenesInput(text) {
  const genes = [];
  text.split('\n').forEach(raw => {
    const line = raw.trim();
    if (!line || line.startsWith('#')) return;
    genes.push(line.split(/\s+/)[0].toUpperCase());
  });
  return genes;
}

// ===========================================================================
// Main execution
// ===========================================================================
async function run() {
  clearResults();
  showStatus();
  setRunning(true);
  resultRows = [];

  const flank = parseInt(document.getElementById('flank-input').value) || 0;

  let geneRegions;

  if (currentMode === 'regions') {
    const text = document.getElementById('input-regions').value.trim();
    if (!text) { log('No input provided.', 'log-err'); setRunning(false); return; }
    geneRegions = parseRegionsInput(text);
  } else {
    const text = document.getElementById('input-genes').value.trim();
    if (!text) { log('No input provided.', 'log-err'); setRunning(false); return; }
    const genes = parseGenesInput(text);
    geneRegions = {};
    genes.forEach(g => geneRegions[g] = 'all');
    log(`Whole-gene mode: ${genes.length} gene(s).`, 'log-info');
  }

  const geneKeys = Object.keys(geneRegions);
  if (geneKeys.length === 0) {
    log('No valid input found.', 'log-err');
    setRunning(false);
    return;
  }

  if (flank > 0) log(`Exonic flanking: +/- ${flank} bp`, 'log-info');
  log(`Reference genome: ${getGenome().fullLabel}\n`, 'log-info');

  for (let gi = 0; gi < geneKeys.length; gi++) {
    const gene = geneKeys[gi];
    const regions = geneRegions[gene];

    setProgress(Math.round(((gi) / geneKeys.length) * 100));
    log(`${'='.repeat(50)}`, 'log-info');
    log(`Processing ${gene} ...`);

    try {
      const searchData = await ucscSearch(gene);
      const loc = findGeneLocation(searchData, gene);
      if (!loc) {
        log(`  ERROR: Could not locate '${gene}' in ${getGenome().label}. Skipping.`, 'log-err');
        continue;
      }
      log(`  Location: ${loc.chrom}:${loc.start}-${loc.end}`);

      const tx = await resolveTranscript(gene, loc.chrom, loc.start, loc.end);
      if (!tx) continue;

      const refseq = tx.name;
      const strand = tx.strand;
      log(`  Transcript: ${refseq} (${tx.exonCount} exons, strand ${strand})`);

      const { exons, introns } = parseTranscript(tx);
      log(`  Introns: ${introns.length}`);

      const exonMap = Object.fromEntries(exons.map(e => [e.number, e]));
      const intronMap = Object.fromEntries(introns.map(i => [i.number, i]));

      let ordered;
      if (regions === 'all') {
        ordered = [];
        for (const n of Object.keys(exonMap).map(Number).sort((a,b) => a-b)) {
          ordered.push({ type: 'exon', number: n });
          if (intronMap[n]) ordered.push({ type: 'int', number: n });
        }
      } else {
        ordered = [...regions].sort((a, b) => a.number - b.number);
      }

      for (const { type, number } of ordered) {
        if (type === 'int') {
          const r = intronMap[number];
          if (!r) {
            log(`  WARNING: ${gene}_int_${number} not found (${introns.length} introns).`, 'log-warn');
            continue;
          }
          const name = `${gene}_int_${number}`;
          resultRows.push({ chrom: r.chrom, start: r.start, end: r.end, name, refseq, strand });
          log(`    ${name}  ${r.chrom}:${r.start}-${r.end}`, 'log-ok');

        } else if (type === 'exon') {
          const r = exonMap[number];
          if (!r) {
            log(`  WARNING: ${gene}_exon_${number} not found (${exons.length} exons).`, 'log-warn');
            continue;
          }
          let start = r.start;
          let end = r.end;
          let name = `${gene}_exon_${number}`;
          if (flank > 0) {
            start -= flank;
            end += flank;
            name += `_flank${flank}bp`;
          }
          resultRows.push({ chrom: r.chrom, start, end, name, refseq, strand });
          log(`    ${name}  ${r.chrom}:${start}-${end}`, 'log-ok');
        }
      }

    } catch (err) {
      log(`  ERROR: ${err.message}`, 'log-err');
    }
  }

  setProgress(100);
  log(`\n${'='.repeat(50)}`);
  log(`Done. ${resultRows.length} region(s) extracted.`, 'log-ok');

  renderResults();
  setRunning(false);
}

// ===========================================================================
// BED download
// ===========================================================================
function downloadBED() {
  if (resultRows.length === 0) return;

  const geneOrder = [];
  const geneMap = {};
  resultRows.forEach(r => {
    const gene = r.name.replace(/_(exon|int)_.*$/, '');
    if (!geneMap[gene]) {
      geneMap[gene] = { exons: [], introns: [], refseq: r.refseq };
      geneOrder.push(gene);
    }
    if (r.name.includes('_exon_')) {
      geneMap[gene].exons.push(r);
    } else {
      geneMap[gene].introns.push(r);
    }
  });

  let bed = `#genome=${getGenome().label}\n#chrom\tstart\tend\tname\trefseq_id\tstrand\n`;
  for (const gene of geneOrder) {
    const g = geneMap[gene];
    if (g.exons.length > 0) {
      bed += `# ${gene} Exons (${g.refseq})\n`;
      g.exons.forEach(r => {
        bed += `${r.chrom}\t${r.start}\t${r.end}\t${r.name}\t${r.refseq}\t${r.strand}\n`;
      });
    }
    if (g.introns.length > 0) {
      bed += `# ${gene} Introns (${g.refseq})\n`;
      g.introns.forEach(r => {
        bed += `${r.chrom}\t${r.start}\t${r.end}\t${r.name}\t${r.refseq}\t${r.strand}\n`;
      });
    }
  }

  const blob = new Blob([bed], { type: 'text/tab-separated-values' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `gene_coordinates_${getGenome().label}.bed`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
</script>
</body>
</html>
