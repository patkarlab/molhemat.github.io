<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gene Coordinate Extractor</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@400;500&family=Source+Serif+4:ital,opsz,wght@0,8..60,300;0,8..60,400;0,8..60,600;0,8..60,700;1,8..60,400&family=DM+Sans:wght@400;500;600&display=swap" rel="stylesheet">
<style>
  :root {
    --ink: #1a1a2e;
    --paper: #f8f7f4;
    --accent: #2d6a4f;
    --accent-light: #d8f3dc;
    --accent-dim: #40916c;
    --border: #d4d0c8;
    --border-strong: #b8b4aa;
    --muted: #6b6b6b;
    --error: #9b2226;
    --error-bg: #fdf0f0;
    --warn: #bc6c25;
    --code-bg: #eae8e3;
    --table-stripe: #f2f0ec;
    --shadow: 0 1px 3px rgba(0,0,0,0.06), 0 4px 12px rgba(0,0,0,0.04);
    --shadow-lg: 0 2px 8px rgba(0,0,0,0.08), 0 8px 24px rgba(0,0,0,0.06);
    --radius: 4px;
    --font-serif: 'Source Serif 4', Georgia, serif;
    --font-sans: 'DM Sans', -apple-system, sans-serif;
    --font-mono: 'DM Mono', 'Menlo', monospace;
  }

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  html { font-size: 16px; -webkit-font-smoothing: antialiased; }

  body {
    font-family: var(--font-sans);
    background: var(--paper);
    color: var(--ink);
    line-height: 1.6;
    min-height: 100vh;
  }

  /* --- Top bar --- */
  .topbar {
    background: var(--ink);
    color: var(--paper);
    padding: 10px 0;
    font-size: 0.72rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    font-family: var(--font-mono);
  }
  .topbar-inner {
    max-width: 960px;
    margin: 0 auto;
    padding: 0 24px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .topbar a {
    color: var(--accent-light);
    text-decoration: none;
  }

  /* --- Header --- */
  header {
    max-width: 960px;
    margin: 0 auto;
    padding: 48px 24px 0;
  }
  header h1 {
    font-family: var(--font-serif);
    font-weight: 700;
    font-size: 2rem;
    line-height: 1.2;
    letter-spacing: -0.02em;
    margin-bottom: 8px;
  }
  header h1 span {
    font-weight: 300;
    color: var(--muted);
  }
  header p.subtitle {
    color: var(--muted);
    font-size: 0.92rem;
    max-width: 640px;
    margin-bottom: 0;
  }

  .rule {
    max-width: 960px;
    margin: 24px auto;
    padding: 0 24px;
  }
  .rule hr {
    border: none;
    border-top: 1px solid var(--border);
  }

  /* --- Main layout --- */
  main {
    max-width: 960px;
    margin: 0 auto;
    padding: 0 24px 64px;
  }

  /* --- Mode tabs --- */
  .mode-tabs {
    display: flex;
    gap: 0;
    margin-bottom: 28px;
    border-bottom: 2px solid var(--border);
  }
  .mode-tab {
    padding: 10px 20px;
    font-family: var(--font-mono);
    font-size: 0.82rem;
    font-weight: 500;
    letter-spacing: 0.02em;
    cursor: pointer;
    border: none;
    background: none;
    color: var(--muted);
    position: relative;
    transition: color 0.15s;
  }
  .mode-tab:hover { color: var(--ink); }
  .mode-tab.active {
    color: var(--accent);
  }
  .mode-tab.active::after {
    content: '';
    position: absolute;
    bottom: -2px;
    left: 0;
    right: 0;
    height: 2px;
    background: var(--accent);
  }

  /* --- Form sections --- */
  .form-section { margin-bottom: 24px; }

  label {
    display: block;
    font-family: var(--font-mono);
    font-size: 0.78rem;
    font-weight: 500;
    letter-spacing: 0.03em;
    text-transform: uppercase;
    color: var(--muted);
    margin-bottom: 6px;
  }
  label .hint {
    text-transform: none;
    font-weight: 400;
    letter-spacing: 0;
    display: block;
    margin-top: 2px;
    font-size: 0.75rem;
    color: #999;
  }

  textarea {
    width: 100%;
    min-height: 160px;
    padding: 12px 14px;
    font-family: var(--font-mono);
    font-size: 0.85rem;
    line-height: 1.65;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: #fff;
    color: var(--ink);
    resize: vertical;
    transition: border-color 0.15s;
  }
  textarea:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(45,106,79,0.08);
  }
  textarea::placeholder { color: #bbb; }

  .options-row {
    display: flex;
    gap: 24px;
    align-items: flex-end;
    flex-wrap: wrap;
  }

  .option-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .option-group input[type="number"] {
    width: 80px;
    padding: 8px 10px;
    font-family: var(--font-mono);
    font-size: 0.85rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: #fff;
  }
  .option-group input[type="number"]:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(45,106,79,0.08);
  }
  .option-group select {
    padding: 8px 10px;
    font-family: var(--font-mono);
    font-size: 0.85rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: #fff;
    color: var(--ink);
    cursor: pointer;
    min-width: 120px;
  }
  .option-group select:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(45,106,79,0.08);
  }

  /* --- Buttons --- */
  .btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 10px 22px;
    font-family: var(--font-sans);
    font-size: 0.88rem;
    font-weight: 600;
    border-radius: var(--radius);
    border: none;
    cursor: pointer;
    transition: all 0.15s;
  }
  .btn-primary {
    background: var(--accent);
    color: #fff;
  }
  .btn-primary:hover { background: var(--accent-dim); }
  .btn-primary:disabled {
    background: var(--border);
    color: var(--muted);
    cursor: not-allowed;
  }
  .btn-secondary {
    background: #fff;
    color: var(--ink);
    border: 1px solid var(--border);
  }
  .btn-secondary:hover { border-color: var(--border-strong); background: var(--table-stripe); }
  .btn-secondary:disabled {
    color: var(--border);
    cursor: not-allowed;
  }

  .actions-row {
    display: flex;
    gap: 12px;
    align-items: center;
    flex-wrap: wrap;
    margin-top: 24px;
  }

  /* --- Status / log --- */
  #status-area {
    margin-top: 24px;
    display: none;
  }
  #status-area.visible { display: block; }

  .log-box {
    background: var(--ink);
    color: #c8c8c8;
    font-family: var(--font-mono);
    font-size: 0.78rem;
    line-height: 1.7;
    padding: 16px 18px;
    border-radius: var(--radius);
    max-height: 200px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-break: break-all;
  }
  .log-box .log-ok { color: #95d5b2; }
  .log-box .log-warn { color: #f4a261; }
  .log-box .log-err { color: #e76f51; }
  .log-box .log-info { color: #89b4fa; }

  /* --- Progress --- */
  .progress-bar {
    height: 3px;
    background: var(--border);
    border-radius: 2px;
    margin-bottom: 12px;
    overflow: hidden;
  }
  .progress-bar-fill {
    height: 100%;
    background: var(--accent);
    width: 0%;
    transition: width 0.3s ease;
  }

  /* --- Results --- */
  #results-area {
    margin-top: 32px;
    display: none;
  }
  #results-area.visible { display: block; }

  .results-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    flex-wrap: wrap;
    gap: 12px;
  }
  .results-header h2 {
    font-family: var(--font-serif);
    font-size: 1.25rem;
    font-weight: 600;
  }
  .results-header .count {
    font-family: var(--font-mono);
    font-size: 0.78rem;
    color: var(--muted);
  }

  .results-table-wrapper {
    overflow-x: auto;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    background: #fff;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.84rem;
  }
  thead th {
    font-family: var(--font-mono);
    font-size: 0.72rem;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: var(--muted);
    text-align: left;
    padding: 10px 14px;
    border-bottom: 2px solid var(--border);
    background: var(--table-stripe);
    position: sticky;
    top: 0;
    white-space: nowrap;
  }
  tbody td {
    padding: 7px 14px;
    font-family: var(--font-mono);
    font-size: 0.8rem;
    border-bottom: 1px solid #eee;
    white-space: nowrap;
  }
  tbody tr:nth-child(even) { background: var(--table-stripe); }
  tbody tr:hover { background: var(--accent-light); }

  td.region-int { color: var(--accent-dim); }
  td.region-exon { color: #6c3483; font-weight: 500; }

  .result-section {
    margin-bottom: 32px;
  }
  .result-section:last-child { margin-bottom: 0; }

  .section-label {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
  }
  .section-label h3 {
    font-family: var(--font-serif);
    font-size: 1.05rem;
    font-weight: 600;
    color: var(--ink);
  }
  .section-label .section-tag {
    font-family: var(--font-mono);
    font-size: 0.68rem;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    padding: 2px 8px;
    border-radius: 3px;
  }
  .section-tag-exon {
    background: #f0e6f6;
    color: #6c3483;
  }
  .section-tag-intron {
    background: var(--accent-light);
    color: var(--accent);
  }
  .section-label .section-count {
    font-family: var(--font-mono);
    font-size: 0.72rem;
    color: var(--muted);
    margin-left: auto;
  }

  .transcript-badge {
    display: inline-block;
    font-family: var(--font-mono);
    font-size: 0.72rem;
    padding: 2px 7px;
    background: var(--code-bg);
    border-radius: 3px;
    color: var(--ink);
  }

  /* --- Footer --- */
  footer {
    max-width: 960px;
    margin: 0 auto;
    padding: 24px;
    border-top: 1px solid var(--border);
    font-size: 0.78rem;
    color: var(--muted);
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 8px;
  }

  /* --- Responsive --- */
  @media (max-width: 640px) {
    header h1 { font-size: 1.5rem; }
    .options-row { flex-direction: column; gap: 16px; }
    .actions-row { flex-direction: column; }
    .btn { width: 100%; justify-content: center; }
    .results-header { flex-direction: column; align-items: flex-start; }
  }

  /* --- Spinner --- */
  .spinner {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid rgba(255,255,255,0.3);
    border-top-color: #fff;
    border-radius: 50%;
    animation: spin 0.6s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* hidden util */
  .hidden { display: none !important; }
</style>
</head>
<body>

<div class="topbar">
  <div class="topbar-inner">
    <span id="topbar-genome">GRCh38 / hg38</span>
    <span>Source: <a href="https://api.genome.ucsc.edu" target="_blank" rel="noopener">UCSC Genome Browser API</a></span>
  </div>
</div>

<header>
  <h1>Gene Coordinate Extractor <span id="header-genome">/ hg38</span></h1>
  <p class="subtitle">
    Retrieve exonic and intronic coordinates for human genes using the MANE Select
    transcript. All queries run client-side against the UCSC REST API.
  </p>
</header>

<div class="rule"><hr></div>

<main>
  <!-- Mode tabs -->
  <div class="mode-tabs">
    <button class="mode-tab active" data-mode="regions" onclick="switchMode('regions')">
      Specific Regions
    </button>
    <button class="mode-tab" data-mode="genes" onclick="switchMode('genes')">
      Whole Gene
    </button>
  </div>

  <!-- Mode 1: Specific regions -->
  <div id="panel-regions" class="form-section">
    <label for="input-regions">
      Regions
      <span class="hint">One per line: GENE_int_N or GENE_exon_N (e.g. ALK_int_19, BRAF_exon_15)</span>
    </label>
    <textarea id="input-regions" spellcheck="false" placeholder="ALK_int_15
ALK_int_16
ALK_int_17
ALK_int_18
ALK_int_19
ALK_int_20
ALK_int_21
ALK_exon_20
BRAF_exon_15"></textarea>
  </div>

  <!-- Mode 2: Whole gene -->
  <div id="panel-genes" class="form-section hidden">
    <label for="input-genes">
      Gene Symbols
      <span class="hint">One per line (e.g. ALK, BRAF, ROS1). All exons and introns will be extracted.</span>
    </label>
    <textarea id="input-genes" spellcheck="false" placeholder="ALK
BRAF
ROS1"></textarea>
  </div>

  <!-- Options -->
  <div class="options-row">
    <div class="option-group">
      <label for="genome-select">
        Reference Genome
        <span class="hint">Genome assembly for coordinate queries</span>
      </label>
      <select id="genome-select" onchange="switchGenome(this.value)">
        <option value="hg38" selected>hg38 (GRCh38)</option>
        <option value="hg19">hg19 (GRCh37)</option>
        <option value="hs1">T2T (CHM13)</option>
      </select>
    </div>
    <div class="option-group">
      <label for="flank-input">
        Exon flank (bp)
        <span class="hint">Extend exonic regions into flanking introns (e.g. 10 for splice sites)</span>
      </label>
      <input type="number" id="flank-input" value="0" min="0" max="1000" step="1">
    </div>
  </div>

  <!-- Actions -->
  <div class="actions-row">
    <button class="btn btn-primary" id="btn-run" onclick="run()">
      Extract Coordinates
    </button>
    <button class="btn btn-secondary" id="btn-download" onclick="downloadBED()" disabled>
      Download BED
    </button>
    <button class="btn btn-secondary" id="btn-clear" onclick="clearResults()">
      Clear
    </button>
  </div>

  <!-- Status -->
  <div id="status-area">
    <div class="progress-bar"><div class="progress-bar-fill" id="progress-fill"></div></div>
    <div class="log-box" id="log-box"></div>
  </div>

  <!-- Results -->
  <div id="results-area">
    <div class="results-header">
      <h2>Results</h2>
      <span class="count" id="results-count"></span>
    </div>
    <div id="results-container"></div>
  </div>
</main>

<footer>
  <span id="footer-info">Coordinates: 0-based, half-open (BED convention). Transcript: MANE Select via ncbiRefSeqSelect.</span>
  <span>No data leaves your browser.</span>
</footer>

<script>
// ---------------------------------------------------------------------------
// State
// ---------------------------------------------------------------------------
let currentMode = 'regions';
let resultRows = [];

const GENOME_CONFIG = {
  hg38: { ucsc: 'hg38', label: 'hg38', fullLabel: 'GRCh38 / hg38' },
  hg19: { ucsc: 'hg19', label: 'hg19', fullLabel: 'GRCh37 / hg19' },
  hs1:  { ucsc: 'hs1',  label: 'T2T',  fullLabel: 'T2T-CHM13 / hs1' },
};
let currentGenome = 'hg38';

function getGenome() {
  return GENOME_CONFIG[currentGenome];
}

// ---------------------------------------------------------------------------
// UI helpers
// ---------------------------------------------------------------------------
function switchGenome(genome) {
  currentGenome = genome;
  const cfg = getGenome();
  document.getElementById('topbar-genome').textContent = cfg.fullLabel;
  document.getElementById('header-genome').textContent = '/ ' + cfg.label;
  document.title = 'Gene Coordinate Extractor | ' + cfg.label;
}
function switchMode(mode) {
  currentMode = mode;
  document.querySelectorAll('.mode-tab').forEach(t => {
    t.classList.toggle('active', t.dataset.mode === mode);
  });
  document.getElementById('panel-regions').classList.toggle('hidden', mode !== 'regions');
  document.getElementById('panel-genes').classList.toggle('hidden', mode !== 'genes');
}

function setRunning(running) {
  const btn = document.getElementById('btn-run');
  if (running) {
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner"></span> Running...';
  } else {
    btn.disabled = false;
    btn.textContent = 'Extract Coordinates';
  }
}

function showStatus() {
  document.getElementById('status-area').classList.add('visible');
}

function setProgress(pct) {
  document.getElementById('progress-fill').style.width = pct + '%';
}

const logEl = document.getElementById('log-box');
function log(msg, cls) {
  const span = document.createElement('span');
  if (cls) span.className = cls;
  span.textContent = msg + '\n';
  logEl.appendChild(span);
  logEl.scrollTop = logEl.scrollHeight;
}

function clearLog() {
  logEl.innerHTML = '';
  setProgress(0);
}

function clearResults() {
  resultRows = [];
  document.getElementById('results-area').classList.remove('visible');
  document.getElementById('status-area').classList.remove('visible');
  document.getElementById('results-container').innerHTML = '';
  document.getElementById('btn-download').disabled = true;
  clearLog();
}

function buildTable(rows) {
  const wrapper = document.createElement('div');
  wrapper.className = 'results-table-wrapper';
  const table = document.createElement('table');
  table.innerHTML = `
    <thead>
      <tr>
        <th>Chrom</th>
        <th>Start</th>
        <th>End</th>
        <th>Name</th>
        <th>RefSeq ID</th>
        <th>Strand</th>
      </tr>
    </thead>
  `;
  const tbody = document.createElement('tbody');
  rows.forEach(r => {
    const tr = document.createElement('tr');
    const isExon = r.name.includes('_exon_');
    const cls = isExon ? 'region-exon' : 'region-int';
    tr.innerHTML = `
      <td>${r.chrom}</td>
      <td>${r.start.toLocaleString()}</td>
      <td>${r.end.toLocaleString()}</td>
      <td class="${cls}">${r.name}</td>
      <td><span class="transcript-badge">${r.refseq}</span></td>
      <td>${r.strand}</td>
    `;
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
  wrapper.appendChild(table);
  return wrapper;
}

function renderResults() {
  const container = document.getElementById('results-container');
  container.innerHTML = '';

  // Group rows by gene, then split exon vs intron within each gene
  const geneOrder = [];
  const geneMap = {};
  resultRows.forEach(r => {
    // Extract gene name from the region name (everything before _exon_ or _int_)
    const gene = r.name.replace(/_(exon|int)_.*$/, '');
    if (!geneMap[gene]) {
      geneMap[gene] = { exons: [], introns: [], refseq: r.refseq, strand: r.strand };
      geneOrder.push(gene);
    }
    if (r.name.includes('_exon_')) {
      geneMap[gene].exons.push(r);
    } else {
      geneMap[gene].introns.push(r);
    }
  });

  for (const gene of geneOrder) {
    const g = geneMap[gene];

    // Exons section
    if (g.exons.length > 0) {
      const section = document.createElement('div');
      section.className = 'result-section';
      section.innerHTML = `
        <div class="section-label">
          <h3>${gene}</h3>
          <span class="section-tag section-tag-exon">Exons</span>
          <span class="transcript-badge">${g.refseq}</span>
          <span class="section-count">${g.exons.length} region${g.exons.length !== 1 ? 's' : ''}</span>
        </div>
      `;
      section.appendChild(buildTable(g.exons));
      container.appendChild(section);
    }

    // Introns section
    if (g.introns.length > 0) {
      const section = document.createElement('div');
      section.className = 'result-section';
      section.innerHTML = `
        <div class="section-label">
          <h3>${gene}</h3>
          <span class="section-tag section-tag-intron">Introns</span>
          <span class="transcript-badge">${g.refseq}</span>
          <span class="section-count">${g.introns.length} region${g.introns.length !== 1 ? 's' : ''}</span>
        </div>
      `;
      section.appendChild(buildTable(g.introns));
      container.appendChild(section);
    }
  }

  const totalExons = Object.values(geneMap).reduce((s, g) => s + g.exons.length, 0);
  const totalIntrons = Object.values(geneMap).reduce((s, g) => s + g.introns.length, 0);
  document.getElementById('results-count').textContent =
    `${totalExons} exon${totalExons !== 1 ? 's' : ''}, ${totalIntrons} intron${totalIntrons !== 1 ? 's' : ''} across ${geneOrder.length} gene${geneOrder.length !== 1 ? 's' : ''}`;
  document.getElementById('results-area').classList.add('visible');
  document.getElementById('btn-download').disabled = resultRows.length === 0;
}

// ---------------------------------------------------------------------------
// UCSC API
// ---------------------------------------------------------------------------
const UCSC = 'https://api.genome.ucsc.edu';

async function ucscSearch(gene) {
  const genome = getGenome().ucsc;
  const url = `${UCSC}/search?genome=${genome}&search=${encodeURIComponent(gene)}`;
  const r = await fetch(url);
  if (!r.ok) throw new Error(`UCSC search failed for ${gene}: ${r.status}`);
  return r.json();
}

async function ucscTrack(track, chrom, start, end) {
  const genome = getGenome().ucsc;
  const url = `${UCSC}/getData/track?genome=${genome}&track=${track}&chrom=${chrom}&start=${start}&end=${end}`;
  const r = await fetch(url);
  if (!r.ok) throw new Error(`UCSC track fetch failed: ${r.status}`);
  return r.json();
}

// ---------------------------------------------------------------------------
// Gene location resolution
// ---------------------------------------------------------------------------
function parsePosition(pos) {
  const m = pos.match(/^(chr[\dXYMT]+):(\d+)-(\d+)$/);
  if (!m) return null;
  return { chrom: m[1], start: parseInt(m[2]), end: parseInt(m[3]) };
}

function findGeneLocation(searchData, gene) {
  const matches = searchData.positionMatches || [];
  const geneUp = gene.toUpperCase();

  // Prefer MANE or HUGO match
  for (const group of matches) {
    const desc = group.description || '';
    if (desc.includes('MANE') || desc.includes('HUGO')) {
      for (const m of (group.matches || [])) {
        if ((m.posName || '').toUpperCase() === geneUp) {
          return parsePosition(m.position || '');
        }
      }
    }
  }
  // Fallback
  for (const group of matches) {
    for (const m of (group.matches || [])) {
      if ((m.posName || '').toUpperCase() === geneUp) {
        return parsePosition(m.position || '');
      }
    }
  }
  return null;
}

// ---------------------------------------------------------------------------
// Transcript resolution
// ---------------------------------------------------------------------------
async function getMANESelect(gene, chrom, start, end) {
  const data = await ucscTrack('ncbiRefSeqSelect', chrom, start, end);
  const items = data.ncbiRefSeqSelect || [];
  const geneUp = gene.toUpperCase();
  return items.find(t =>
    (t.name2 || '').toUpperCase() === geneUp && (t.name || '').startsWith('NM_')
  ) || null;
}

async function getAllRefSeq(gene, chrom, start, end) {
  const data = await ucscTrack('ncbiRefSeq', chrom, start, end);
  const items = data.ncbiRefSeq || [];
  const geneUp = gene.toUpperCase();
  const seen = new Set();
  return items.filter(t => {
    if ((t.name2 || '').toUpperCase() !== geneUp) return false;
    if (!(t.name || '').startsWith('NM_')) return false;
    if (seen.has(t.name)) return false;
    seen.add(t.name);
    return true;
  });
}

async function resolveTranscript(gene, chrom, start, end) {
  // Try MANE Select
  const mane = await getMANESelect(gene, chrom, start, end);
  if (mane) {
    log(`  MANE Select: ${mane.name}`, 'log-ok');
    return mane;
  }

  // Fallback: list alternatives and let user pick
  const allTx = await getAllRefSeq(gene, chrom, start, end);
  if (allTx.length === 0) {
    log(`  ERROR: No NM_ transcripts found for ${gene}.`, 'log-err');
    return null;
  }
  if (allTx.length === 1) {
    log(`  Single NM_ transcript: ${allTx[0].name}`, 'log-info');
    return allTx[0];
  }

  // Prompt user to choose
  log(`  No MANE Select for ${gene}. Available:`, 'log-warn');
  const options = allTx.map((t, i) => {
    const len = t.txEnd - t.txStart;
    return `[${i + 1}] ${t.name} (${t.exonCount} exons, ${len.toLocaleString()} bp)`;
  });
  options.forEach(o => log('    ' + o, 'log-warn'));

  const choice = prompt(
    `No MANE Select transcript found for ${gene}.\n\n` +
    `Choose a transcript:\n` +
    options.join('\n') +
    `\n\nEnter number (1-${allTx.length}):`
  );

  const idx = parseInt(choice) - 1;
  if (isNaN(idx) || idx < 0 || idx >= allTx.length) {
    log(`  Invalid selection. Skipping ${gene}.`, 'log-err');
    return null;
  }
  log(`  Selected: ${allTx[idx].name}`, 'log-ok');
  return allTx[idx];
}

// ---------------------------------------------------------------------------
// Exon / intron computation
// ---------------------------------------------------------------------------
function parseTranscript(tx) {
  const chrom = tx.chrom;
  const strand = tx.strand;

  const exonStarts = tx.exonStarts.replace(/,$/,'').split(',').map(Number);
  const exonEnds = tx.exonEnds.replace(/,$/,'').split(',').map(Number);

  let exonRegions = exonStarts.map((s, i) => ({ chrom, start: s, end: exonEnds[i] }));

  let intronRegions = [];
  for (let i = 0; i < exonRegions.length - 1; i++) {
    intronRegions.push({
      chrom,
      start: exonRegions[i].end,
      end: exonRegions[i + 1].start,
    });
  }

  // Minus strand: reverse to transcript order
  if (strand === '-') {
    exonRegions = exonRegions.reverse();
    intronRegions = intronRegions.reverse();
  }

  exonRegions.forEach((r, i) => r.number = i + 1);
  intronRegions.forEach((r, i) => r.number = i + 1);

  return { exons: exonRegions, introns: intronRegions };
}

// ---------------------------------------------------------------------------
// Input parsing
// ---------------------------------------------------------------------------
function parseRegionsInput(text) {
  const pattern = /^([A-Za-z0-9_.\-]+)_(int|intron|exon)_(\d+)$/i;
  const geneRegions = {};

  text.split('\n').forEach((raw, idx) => {
    const line = raw.trim();
    if (!line || line.startsWith('#')) return;
    const m = line.match(pattern);
    if (!m) {
      log(`  WARNING: skipping line ${idx + 1}: '${line}'`, 'log-warn');
      return;
    }
    const gene = m[1].toUpperCase();
    let type = m[2].toLowerCase();
    if (type === 'intron') type = 'int';
    const num = parseInt(m[3]);
    if (!geneRegions[gene]) geneRegions[gene] = [];
    geneRegions[gene].push({ type, number: num });
  });

  return geneRegions;
}

function parseGenesInput(text) {
  const genes = [];
  text.split('\n').forEach(raw => {
    const line = raw.trim();
    if (!line || line.startsWith('#')) return;
    genes.push(line.split(/\s+/)[0].toUpperCase());
  });
  return genes;
}

// ---------------------------------------------------------------------------
// Main execution
// ---------------------------------------------------------------------------
async function run() {
  clearResults();
  showStatus();
  setRunning(true);
  resultRows = [];

  const flank = parseInt(document.getElementById('flank-input').value) || 0;

  let geneRegions;  // { GENE: [{type, number}] } or { GENE: 'all' }

  if (currentMode === 'regions') {
    const text = document.getElementById('input-regions').value.trim();
    if (!text) { log('No input provided.', 'log-err'); setRunning(false); return; }
    geneRegions = parseRegionsInput(text);
  } else {
    const text = document.getElementById('input-genes').value.trim();
    if (!text) { log('No input provided.', 'log-err'); setRunning(false); return; }
    const genes = parseGenesInput(text);
    geneRegions = {};
    genes.forEach(g => geneRegions[g] = 'all');
    log(`Whole-gene mode: ${genes.length} gene(s).`, 'log-info');
  }

  const geneKeys = Object.keys(geneRegions);
  if (geneKeys.length === 0) {
    log('No valid input found.', 'log-err');
    setRunning(false);
    return;
  }

  if (flank > 0) log(`Exonic flanking: +/- ${flank} bp`, 'log-info');
  log(`Reference genome: ${getGenome().fullLabel}\n`, 'log-info');

  for (let gi = 0; gi < geneKeys.length; gi++) {
    const gene = geneKeys[gi];
    const regions = geneRegions[gene];

    setProgress(Math.round(((gi) / geneKeys.length) * 100));
    log(`${'='.repeat(50)}`, 'log-info');
    log(`Processing ${gene} ...`);

    try {
      // Step 1: locate gene
      const searchData = await ucscSearch(gene);
      const loc = findGeneLocation(searchData, gene);
      if (!loc) {
        log(`  ERROR: Could not locate '${gene}' in ${getGenome().label}. Skipping.`, 'log-err');
        continue;
      }
      log(`  Location: ${loc.chrom}:${loc.start}-${loc.end}`);

      // Step 2: resolve transcript
      const tx = await resolveTranscript(gene, loc.chrom, loc.start, loc.end);
      if (!tx) continue;

      const refseq = tx.name;
      const strand = tx.strand;
      log(`  Transcript: ${refseq} (${tx.exonCount} exons, strand ${strand})`);

      // Step 3: compute regions
      const { exons, introns } = parseTranscript(tx);
      log(`  Introns: ${introns.length}`);

      const exonMap = Object.fromEntries(exons.map(e => [e.number, e]));
      const intronMap = Object.fromEntries(introns.map(i => [i.number, i]));

      // Step 4: determine which to output
      let ordered;
      if (regions === 'all') {
        ordered = [];
        for (const n of Object.keys(exonMap).map(Number).sort((a,b) => a-b)) {
          ordered.push({ type: 'exon', number: n });
          if (intronMap[n]) ordered.push({ type: 'int', number: n });
        }
      } else {
        ordered = [...regions].sort((a, b) => a.number - b.number);
      }

      // Step 5: emit rows
      for (const { type, number } of ordered) {
        if (type === 'int') {
          const r = intronMap[number];
          if (!r) {
            log(`  WARNING: ${gene}_int_${number} not found (${introns.length} introns).`, 'log-warn');
            continue;
          }
          const name = `${gene}_int_${number}`;
          resultRows.push({ chrom: r.chrom, start: r.start, end: r.end, name, refseq, strand });
          log(`    ${name}  ${r.chrom}:${r.start}-${r.end}`, 'log-ok');

        } else if (type === 'exon') {
          const r = exonMap[number];
          if (!r) {
            log(`  WARNING: ${gene}_exon_${number} not found (${exons.length} exons).`, 'log-warn');
            continue;
          }
          let start = r.start;
          let end = r.end;
          let name = `${gene}_exon_${number}`;
          if (flank > 0) {
            start -= flank;
            end += flank;
            name += `_flank${flank}bp`;
          }
          resultRows.push({ chrom: r.chrom, start, end, name, refseq, strand });
          log(`    ${name}  ${r.chrom}:${start}-${end}`, 'log-ok');
        }
      }

    } catch (err) {
      log(`  ERROR: ${err.message}`, 'log-err');
    }
  }

  setProgress(100);
  log(`\n${'='.repeat(50)}`);
  log(`Done. ${resultRows.length} region(s) extracted.`, 'log-ok');

  renderResults();
  setRunning(false);
}

// ---------------------------------------------------------------------------
// BED download
// ---------------------------------------------------------------------------
function downloadBED() {
  if (resultRows.length === 0) return;

  // Group by gene, exons before introns
  const geneOrder = [];
  const geneMap = {};
  resultRows.forEach(r => {
    const gene = r.name.replace(/_(exon|int)_.*$/, '');
    if (!geneMap[gene]) {
      geneMap[gene] = { exons: [], introns: [], refseq: r.refseq };
      geneOrder.push(gene);
    }
    if (r.name.includes('_exon_')) {
      geneMap[gene].exons.push(r);
    } else {
      geneMap[gene].introns.push(r);
    }
  });

  let bed = `#genome=${getGenome().label}\n#chrom\tstart\tend\tname\trefseq_id\tstrand\n`;
  for (const gene of geneOrder) {
    const g = geneMap[gene];
    if (g.exons.length > 0) {
      bed += `# ${gene} Exons (${g.refseq})\n`;
      g.exons.forEach(r => {
        bed += `${r.chrom}\t${r.start}\t${r.end}\t${r.name}\t${r.refseq}\t${r.strand}\n`;
      });
    }
    if (g.introns.length > 0) {
      bed += `# ${gene} Introns (${g.refseq})\n`;
      g.introns.forEach(r => {
        bed += `${r.chrom}\t${r.start}\t${r.end}\t${r.name}\t${r.refseq}\t${r.strand}\n`;
      });
    }
  }

  const blob = new Blob([bed], { type: 'text/tab-separated-values' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `gene_coordinates_${getGenome().label}.bed`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
</script>
</body>
</html>
